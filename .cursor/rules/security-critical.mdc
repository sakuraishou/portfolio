---
title: 重要セキュリティパターン
description: Payload CMS における最重要セキュリティパターン3つ
tags: [payload, security, critical, access-control, transactions, hooks]
priority: high
---

# 重要セキュリティパターン

Payload CMS のすべてのプロジェクトで必ず守らなければならない、最重要セキュリティパターン3つです。

## 1. Local API のアクセス制御（最重要）

**Local API の操作はデフォルトでアクセス制御をすべてスキップします。** user を渡していても同様です。

```typescript
// ❌ セキュリティバグ: user を渡してもその権限は無視される
await payload.find({
  collection: 'posts',
  user: someUser, // アクセス制御がスキップされる！
})

// ✅ 安全: ユーザーの権限を正しく強制する
await payload.find({
  collection: 'posts',
  user: someUser,
  overrideAccess: false, // アクセス制御に必須
})

// ✅ 管理操作（意図的なバイパス）
await payload.find({
  collection: 'posts',
  // user なし、overrideAccess はデフォルトで true
})
```

**使い分け:**

- `overrideAccess: true`（デフォルト）— 信頼できるサーバーサイド操作（cronジョブ・システムタスク）
- `overrideAccess: false` — ユーザーの代わりに操作する場合（APIルート・Webhook）

**ルール**: Local API に `user` を渡す場合は、必ず `overrideAccess: false` を設定する

## 2. フック内のトランザクション安全性

**フック内で `req` なしにネスト操作を行うと、トランザクションのアトミック性が壊れます。**

```typescript
// ❌ データ破損リスク: 別トランザクションになる
hooks: {
  afterChange: [
    async ({ doc, req }) => {
      await req.payload.create({
        collection: 'audit-log',
        data: { docId: doc.id },
        // req がない → 別トランザクションで実行される！
      })
    },
  ]
}

// ✅ アトミック: 同じトランザクション内で実行
hooks: {
  afterChange: [
    async ({ doc, req }) => {
      await req.payload.create({
        collection: 'audit-log',
        data: { docId: doc.id },
        req, // アトミック性を維持
      })
    },
  ]
}
```

**なぜ重要か:**

- **MongoDB（レプリカセット使用時）**: 操作間でアトミックなセッションを作る
- **PostgreSQL**: 全操作が同じ Drizzle トランザクションを使う
- **SQLite（トランザクション有効時）**: エラー時のロールバックを保証する
- **req なしの場合**: 各操作が独立して実行され、アトミック性が壊れる

**ルール**: フック内のネスト操作には必ず `req` を渡す

## 3. フックの無限ループ防止

**フックが同じフックをトリガーする操作を呼ぶと、無限ループが発生します。**

```typescript
// ❌ 無限ループ
hooks: {
  afterChange: [
    async ({ doc, req }) => {
      await req.payload.update({
        collection: 'posts',
        id: doc.id,
        data: { views: doc.views + 1 },
        req,
      }) // 再び afterChange が呼ばれる！
    },
  ]
}

// ✅ 安全: context フラグを使う
hooks: {
  afterChange: [
    async ({ doc, req, context }) => {
      if (context.skipHooks) return

      await req.payload.update({
        collection: 'posts',
        id: doc.id,
        data: { views: doc.views + 1 },
        context: { skipHooks: true },
        req,
      })
    },
  ]
}
```

**ルール**: フックのループ防止には `req.context` フラグを使う
